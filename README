Lab 6 Submission_2 by
        Rahul Singhal 110050023
        Ved Ratn Dixit 110050044

Ans 1) Code that performs booting action is present in the file by the name of guestos.c
    
    It basicaly does two things

    i)  Sets up the signals=handlers using the signal command under the function "install_signals();"

    ii) Makes a virtual disk using the "dd" command which it executes using the "system" command.    All this happens in the function "set_defaults();" which is called from the boot function
        wherein the ".config" file is read to figure the desired configuration of the disk-system. This file is used to set the number of head, tracks, sectors and instruction-slice variables for the guest os.
        All this functionality is very conviniently provided by the "dd" function mentioned earlier
        which is directly used by the pranali os to use a file of head * tracks * sectors * (512) bytes as its virtual disk-space.

        The three parameters used in the dd command provide the following functionality
        if=FILE
              read from FILE instead of stdin
              **** in our case this is set to /dev/zero ****

        of=FILE
              write to FILE instead of stdout
              **** in our case this is set to Simdisk ( this is a file in the guestos folder ) ****

        bs=BYTES
              read and write up to BYTES bytes at a time
              **** in our case it is "2 * 80 * 18 b" units where each b unit is equivalent of 512 
              bytes ****




Ans 2)  The .config file in the "guestos" folder specifies the parameters used for configuring the 
        disk space.
        INSTR_SLICE=10
        NUM_HEADS=10
        NUM_TRACKS=100
        NUM_SECTORS=100

        Now the output file "Simdisk" should be of size 51.2 MB. This is indeed what happened.



Ans 3) 
    a)  The system calls are handled by file syscall.c in "src/libm2skernel/". All systemcalls 
        gain entry to this syscall-handling structure through syscall_do(). There are a total 
        327 system calls handled by the os. One of which is (namely get_pid) is handled by the
        guestos and the rest 326 of them are handled by the HostOs.

        This syscall_do() function is called in the inbuilt "op_int_imm8_impl" function in the file "src/libm2skernel/machine.c". 

    b)  There is only one system call handled by the guestos right now. Its name is  
        syscall_code_get_pid which basically returns the pid of the process.

    c)  A system call is passed on to the guest_os_system_call_handler whenever the "syscode" is 
        greater than 325. Otherwise the host handles the systemcalls in a switch statement on the
        "syscode" of the system call. Then it discreetly handles some selected commands such 
        as syscall_code_exit, syscall_code_close, syscall_code_read under a switch statement.

    d)  The address space of a process is accessed by the call-handler in the following manner:
        1)  The system registers under the name of isa_regs are used to get information about the
            running process.
        2)  Then the "fdt_entry_get" function is used to get the file descriptor.
        3)  Then a buffer is allocated using the function "calloc"
        4)  The "poll" function is used to poll the fd to check if the read is blocking
        5)  After which "read" functin is used with "O_NONBLOCK" flag to read the required
            information.

Ans 4)
    A ctx_t struct is defined in the file m2skernel.h . This struct stores all the information 
    about the context of a process like its status, pid, memory id, parent proces pointer, exit-
    signal, exit_code etc, instruction_slice etc. This struct is then used in the context.c file
    of guestos/src which provides the tools to create, dump, execute , clone and update the status of all the processes under the control of the os.

    1)  To find the PCBs of all the processes we'll need to access the kernel_t struct which holds
        all the information of a kernel in its datamembers. This includes the following six lists:

            struct ctx_t *context_list_head, *context_list_tail;
            struct ctx_t *running_list_head, *running_list_tail;
            struct ctx_t *suspended_list_head, *suspended_list_tail;
            struct ctx_t *zombie_list_head, *zombie_list_tail;
            struct ctx_t *finished_list_head, *finished_list_tail;
            struct ctx_t *alloc_list_head, *alloc_list_tail;

        which are the head and tail pointers of to all processlists under the operating system.
        These list pointers can be used to access all the information (PCB) of any process in the
        control of the operating system.

    2)  As mentioned earlier the ctx_t struct holds the instruction-slice of a process under the
        fieldname "int instr_slice;"

    3)  The function ke_run() is called from under the while loop in the main function of guestos.c
        This function runs one instruction of every running process which are accessible to the 
        kernel through the list pointed by running_list_head & running_list_tail after which it 
        free's the contexts who have finished their execution. For running instruction of each 
        context the function "ctx_execute_ins" function is used from file context.c.
        

        --------------------------------------------------------------------------------
        SCHEDULAR CODE IS CORRECTED TO RUN ALL THE PROCESS AS PER THEIR INSTUCTION SLICE
        --------------------------------------------------------------------------------

Ans 5 a)
	FInd the test_files in 5_a folder in testfiles folder in the current directory. 5_a_1.cpp runs with instr_slice = 8 and 5_b_2.cpp runs with instr_slice = 20;
	
		How to create run : 
			1. g++-4.4.3 -m32 -static ../testfiles/5_a/5_a_1.c -o 5_a_1
			2. g++-4.4.3 -m32 -static ../testfiles/5_a/5_a_2.c -o 5_a_2
			3. ./src/guestos
			4. Now create two processes and run the processes 5_a_1 and 5_a_2
			
		Output:
			Both the processes do same amount of job. But Prpgram 2 finishes first as it operates at a higher instruction slice.

    5 b)
    Find the testFiles in the 5_b folder in the testfiles folder in the current directory. 
        1. read_and_write.c --- writes and then reads from disk
        2. outOfBounds.c --- tries to read data from outside the disk space allocated.
        3. read.c --- tries to read data from the disk without writing to it.
        
        How to create run : 
        	1. read_and_write.c
        	
        		a) gcc-4.4.3 -m32 -static ../testfiles/5_b/read_and_write.c -o read_and_write
        		b) ./src/guestos
        		c) now run the process read_and_write
        	Output:
        		This program will first write the text "TheQuickBrownFoxJumpsOverTheLazyDog" to the disk and read the same data from the
        		 disk again and print it
        	
        	2. read.c
        		a) gcc-4.4.3 -m32 -static ../testfiles/5_b/read.c -o read
        		b) ./src/guestos
        		c) now run the process read
        	Output:
        		This program will try to read data from a random part in the disk and since that data space is not being used by any user,
        		 it will read some garbage data and provide the warning before doing so.
        		 
        	3. read.c
        		a) gcc-4.4.3 -m32 -static ../testfiles/5_b/outOfBounds.c -o ob
        		b) ./src/guestos
        		c) now run the process ob
        	Output:
        		We have taken the block size as the standard block size i.e. 8KB. So currently there are only 180 blocks on the disk(disk
        		 size 1474560 bytes). This program will try to read data from a location beyond the allowed block numbers. Thus it will show
        		  an error and return.
        		  
        	4. read.c and read_and_write.c
        		a) gcc-4.4.3 -m32 -static ../testfiles/5_b/read.c -o read
        		b) gcc-4.4.3 -m32 -static ../testfiles/5_b/read_and_write.c -o read_and_write
        		b) ./src/guestos
        		c) now run two process read and read_and_write respectively.
        		
        		Output:
        			"read_and_write" completes first(almost every time) and then "read" tries to read from the same disk location as that
        			 written by "read_and_write". Since one user is not allowed to access the data used by another user, "read" shall be
        			  aborted with error("fatal: Cannot read from disk. Space occupied by other user").



        		
        		
        	   

